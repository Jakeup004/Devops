"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SpotbugsTool = void 0;
const BaseTool_1 = require("./BaseTool");
const path = require("path");
const fs = require("fs");
const xml2js = require("xml2js");
const tl = require("azure-pipelines-task-lib/task");
const defaultPluginVersion = '4.7.0';
/**
 * An object that is able to configure the build to run SpotBugs and identify and parse SpotBugs reports
 *
 * @export
 * @class PmdReportParser
 * @implements {IAnalysisToolReportParser}
 */
class SpotbugsTool extends BaseTool_1.BaseTool {
    constructor(buildOutput, boolInputName) {
        super('SpotBugs', buildOutput, boolInputName);
    }
    /**
     * Configures the provided ToolRunner instance with arguments which will invoke the tool represented by this class.
     * @param toolRunner
     * @returns {ToolRunner} ToolRunner instance with arguments applied
     */
    configureBuild(toolRunner) {
        if (this.isEnabled()) {
            console.log(tl.loc('codeAnalysis_ToolIsEnabled'), this.toolName);
            const specifyPluginVersion = tl.getInput('spotbugsGradlePluginVersionChoice') === 'specify';
            if (specifyPluginVersion) {
                // #1: Inject custom script to the Gradle build, triggering a Spotbugs run
                // Add a custom initialisation script to the Gradle run that will apply the Spotbugs plugin and task
                // Set the Spotbugs Gradle plugin version in the script
                const pluginVersion = this.getSpotBugsGradlePluginVersion();
                let initScriptPath = path.join(__dirname, '..', 'spotbugs.gradle');
                let scriptContents = fs.readFileSync(initScriptPath, 'utf8');
                scriptContents = scriptContents.replace('SPOTBUGS_GRADLE_PLUGIN_VERSION', pluginVersion);
                tl.writeFile(initScriptPath, scriptContents);
                // Specify that the build should run the init script
                toolRunner.arg(['-I', initScriptPath]);
            }
            toolRunner.arg(['check']);
        }
        return toolRunner;
    }
    getSpotBugsGradlePluginVersion() {
        const userSpecifiedVersion = tl.getInput('spotbugsGradlePluginVersion');
        if (userSpecifiedVersion) {
            return userSpecifiedVersion.trim();
        }
        return defaultPluginVersion;
    }
    /**
     * Implementers must specify where the XML reports are located
     */
    getBuildReportDir(output) {
        return path.join(output.moduleRoot, 'reports', 'spotbugs');
    }
    /**
     * Report parser that extracts the number of affected files and the number of violations from a report
     *
     * @returns a tuple of [affected_file_count, violation_count]
     */
    parseXmlReport(xmlReport, moduleName) {
        let jsonCounts = [0, 0];
        let reportContent = fs.readFileSync(xmlReport, 'utf-8');
        xml2js.parseString(reportContent, (err, data) => {
            jsonCounts = SpotbugsTool.parseJson(data);
            if (jsonCounts == null) {
                tl.debug(`[CA] Empty or unrecognized SpotBugs XML report ${xmlReport}`);
                return null;
            }
            let violationCount = jsonCounts[1];
            // No files with violations, return now that it has been marked for upload
            if (violationCount === 0) {
                tl.debug(`[CA] A SpotBugs report was found for module '${moduleName}' but it contains no violations`);
                return null;
            }
            tl.debug(`[CA] A SpotBugs report was found for for module '${moduleName}' containing ${violationCount} issues - ${xmlReport}`);
        });
        return jsonCounts;
    }
    /**
     * Extracts the number of affected files and the number of violations from a report JSON object
     * @param data JSON object to parse
     * @returns a tuple of [affected_file_count, violation_count]
     */
    static parseJson(data) {
        var _a, _b, _c;
        // If the file is not XML, or is not from SpotBugs, return immediately
        const classStats = (_c = (_b = (_a = data === null || data === void 0 ? void 0 : data.BugCollection) === null || _a === void 0 ? void 0 : _a.FindBugsSummary[0]) === null || _b === void 0 ? void 0 : _b.PackageStats[0]) === null || _c === void 0 ? void 0 : _c.ClassStats;
        if (!classStats || !classStats.length) {
            return null;
        }
        let fileCount = 0;
        let violationCount = 0;
        // Extract violation and file count data from the sourceFile attribute of ClassStats
        let filesToViolations = new Map(); // Maps files -> number of violations
        classStats.forEach((classStats) => {
            // The below line takes the sourceFile attribute of the classStats tag - it looks like this in the XML
            // <ClassStats class="main.java.TestClassWithErrors" sourceFile="TestClassWithErrors.java" ... />
            let sourceFile = classStats.$.sourceFile;
            let newBugCount = Number(classStats.$.bugs);
            if (newBugCount > 0) {
                // If there was not already an entry, start at 0
                if (!filesToViolations.has(sourceFile)) {
                    filesToViolations.set(sourceFile, 0);
                }
                // Increment bug count
                let oldBugCount = filesToViolations.get(sourceFile);
                filesToViolations.set(sourceFile, oldBugCount + newBugCount);
            }
        });
        // Sum violations across all files for violationCount
        for (let violations of filesToViolations.values()) {
            violationCount += violations;
        }
        // Number of <K,V> pairs in filesToViolations is fileCount
        fileCount = filesToViolations.size;
        return [violationCount, fileCount];
    }
}
exports.SpotbugsTool = SpotbugsTool;
